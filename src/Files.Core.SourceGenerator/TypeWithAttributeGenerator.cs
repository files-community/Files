// Copyright (c) 2023 Files Community
// Licensed under the MIT License. See the LICENSE.

using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using static Files.Core.SourceGenerator.Utilities.SourceGeneratorHelper;

namespace Files.Core.SourceGenerator
{
	public abstract class TypeWithAttributeGenerator : IIncrementalGenerator
	{
		internal abstract string AttributeName { get; }

		private string AttributeFullName => AttributeNamespace + AttributeName;

		internal abstract string? TypeWithAttribute(INamedTypeSymbol typeSymbol, ImmutableArray<AttributeData> attributeList);

		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var generatorAttributes = context.SyntaxProvider.ForAttributeWithMetadataName(
				AttributeFullName,
				(_, _) => true,
				(syntaxContext, _) => syntaxContext
			).Combine(context.CompilationProvider);

			context.RegisterSourceOutput(generatorAttributes, (spc, tuple) =>
			{
				var (ga, compilation) = tuple;

				if (compilation.Assembly.GetAttributes().Any(attrData => attrData.AttributeClass?.ToDisplayString() == DisableSourceGeneratorAttribute))
					return;

				if (ga.TargetSymbol is not INamedTypeSymbol symbol)
					return;

				if (TypeWithAttribute(symbol, ga.Attributes) is { } source)
					spc.AddSource(
						// Avoid duplicate names
						$"{symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted))}_{AttributeFullName}.g.cs",
						source);
			});
		}
	}
}
